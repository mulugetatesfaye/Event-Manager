generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum TicketTypeStatus {
  ACTIVE
  SOLD_OUT
  INACTIVE
}

enum PromoCodeType {
  PERCENTAGE
  FIXED_AMOUNT
  EARLY_BIRD
}

model TicketType {
  id          String            @id @default(uuid())
  eventId     String
  event       Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  name        String            // "General Admission", "VIP", "Student", "Group"
  description String?
  price       Float
  quantity    Int               // Total tickets available for this type
  quantitySold Int              @default(0) // Track sold tickets
  
  // Pricing tiers
  earlyBirdPrice    Float?
  earlyBirdEndDate  DateTime?
  
  // Limits
  minQuantity Int              @default(1)  // Min tickets per purchase
  maxQuantity Int              @default(10) // Max tickets per purchase
  
  // Features
  features    Json?            // ["Access to VIP lounge", "Free drinks", etc.]
  
  // Status
  status      TicketTypeStatus @default(ACTIVE)
  
  // Ordering
  sortOrder   Int              @default(0)
  
  // Relations
  ticketPurchases TicketPurchase[]
  
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  
  @@index([eventId])
  @@index([status])
}

model TicketPurchase {
  id              String       @id @default(uuid())
  registrationId  String
  registration    Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  
  ticketTypeId    String
  ticketType      TicketType   @relation(fields: [ticketTypeId], references: [id])
  
  quantity        Int          @default(1)
  unitPrice       Float        // Price paid per ticket (may differ due to promo)
  subtotal        Float        // quantity * unitPrice
  
  // Promo code usage
  promoCodeId     String?
  promoCode       PromoCode?   @relation(fields: [promoCodeId], references: [id])
  discount        Float        @default(0)
  
  // Seat assignment (optional)
  seatNumbers     String[]     // ["A1", "A2", "B5"]
  
  // Individual ticket identifiers
  ticketNumbers   String[]     // Unique QR codes for each ticket
  
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  @@index([registrationId])
  @@index([ticketTypeId])
  @@index([promoCodeId])
}

model PromoCode {
  id              String         @id @default(uuid())
  code            String         @unique
  eventId         String?        // null = applies to all events
  event           Event?         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  type            PromoCodeType
  discountValue   Float          // percentage (0-100) or fixed amount
  
  // Limits
  maxUses         Int?           // null = unlimited
  usedCount       Int            @default(0)
  maxUsesPerUser  Int            @default(1)
  
  // Validity
  validFrom       DateTime?
  validUntil      DateTime?
  
  // Restrictions
  minPurchaseAmount Float?       // Minimum purchase to use code
  applicableTicketTypes String[]  // Ticket type IDs this applies to
  
  // Status
  isActive        Boolean        @default(true)
  
  // Relations
  ticketPurchases TicketPurchase[]
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  @@index([code])
  @@index([eventId])
  @@index([isActive])
}

model Seat {
  id          String   @id @default(uuid())
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  section     String   // "Section A", "VIP Area"
  row         String?  // "Row 1"
  seatNumber  String   // "A1", "B2"
  
  // Status
  isReserved  Boolean  @default(false)
  reservedBy  String?  // Registration ID
  reservedAt  DateTime?
  
  // Pricing (can override ticket type price for premium seats)
  priceModifier Float? // +10 for front row, etc.
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([eventId, section, seatNumber])
  @@index([eventId])
  @@index([isReserved])
}

enum UserRole {
  ADMIN
  ORGANIZER
  ATTENDEE
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique
  email     String   @unique
  firstName String?
  lastName  String?
  role      UserRole @default(ATTENDEE)
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organizedEvents Event[]        @relation("EventOrganizer")
  registrations   Registration[]
  createdEvents   Event[]        @relation("EventCreator")
  activities Activity[]
}

model Event {
  id          String      @id @default(uuid())
  title       String
  description String?
  imageUrl    String?
  location    String
  venue       String?
  startDate   DateTime
  endDate     DateTime
  capacity    Int
  price       Float       @default(0)
  status      EventStatus @default(DRAFT)
  
  organizerId String
  organizer   User        @relation("EventOrganizer", fields: [organizerId], references: [id])
  
  creatorId   String
  creator     User        @relation("EventCreator", fields: [creatorId], references: [id])
  
  categoryId  String?
  category    Category?   @relation(fields: [categoryId], references: [id])
  
  registrations Registration[]
  activities Activity[]

  ticketTypes TicketType[]
  promoCodes  PromoCode[]
  seats       Seat[]

  requiresSeating Boolean @default(false)
  allowGroupBooking Boolean @default(true)
  groupDiscountPercentage Float? // e.g., 10 for 10% off groups of 5+
  groupMinQuantity Int @default(5)
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([organizerId])
  @@index([status])
  @@index([startDate])
}

model Category {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  description String?
  color       String?
  events      Event[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Registration {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id])
  status    String   @default("CONFIRMED") // CONFIRMED, CANCELLED
  
  metadata  Json?
  ticketNumber String?  @unique @default(cuid())
  
  totalAmount Float  @default(0)
  paymentStatus String? // PENDING, COMPLETED, FAILED
  paymentId String?
  
  // Check-in tracking - Add these new fields
  checkedIn Boolean  @default(false)
  checkedInAt DateTime?
  checkedInBy String? // User ID of who checked them in
  checkInNotes String? @db.Text // Add this field for notes
  qrCode    String?  @unique // QR code data

  // Promo code used (for tracking)
  promoCodeUsed String?
  finalAmount   Float @default(0) // After all discounts
  
  // Transfer tracking
  transferredFrom String? // Registration ID if transferred
  transferredTo   String? // User ID if transferred
  transferredAt   DateTime?

  ticketPurchases TicketPurchase[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([ticketNumber])
  @@index([qrCode])
  @@index([checkedIn]) // Add this index
  @@index([checkedInAt]) // Add this index
}

// Add Activity model for tracking check-in history
model Activity {
  id        String   @id @default(uuid())
  type      String   // CHECK_IN, CHECK_IN_UNDO, BULK_CHECK_IN, etc.
  userId    String
  eventId   String?
  metadata  Json?
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id])
  event     Event?   @relation(fields: [eventId], references: [id])
  
  @@index([type])
  @@index([userId])
  @@index([eventId])
  @@index([createdAt])
}